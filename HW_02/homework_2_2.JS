undefined + 1; // undefined це NaN, тобто відповідь: NaN
'true' == true // 'true' - це string тобто не умова і не може дорівнювати умові true. Відповідь: false
false == 'false' // 'false' - це string тобто не умова і не може дорівнювати умові false. Відповідь: false
null == '' // Відповідь false тому, що null може дорівнювати або собі, або underfined
3 ** (9 / 3); // Відповідь 27, тому що перша дія у дужках, тобто 9/3=3, а потім зведення у ступінь 3**3=27
!!'false' == !!'true' /*  Якщо я правильно зрозумів то в булевих виразах "!" знак - це "НІ" і перетворює !false у true. Якщо !!false,
то перетворює 2 рази, тобто спочатку у true, а потім обратно у false. Аналогічно і з !!true. Але у нас 2 ці елементи - це string,
тобто обидва true, а отже true==true і це true. Це э відповіддю*/
0 || '0' && 1 /* перша дія ('0' && 1) тому, що приоритет оператору "і". Тут значення '0' true оскільки - це string і 1 - це true.
Тобто повертає 1 - оскільки це останнэ значення true. Потім порінюємо 0 || 1. 0 - false, а 1 - це true, а отже повертає перше значення true,
тобто 1. Це є відповіддю*/
1 < 2 < 3 // Відповідь: true тому, що умова вірна
'foo'+ + +'bar' /* 1 елемент - це string і відбувається конкатенация з 2 елементом.
Це аріфметична операція. 2 елемент +'bar' не є числом і тому результатом є NaN.
Після конкатенаціі з 1 елементом відповідь: fooNaN */
3 ** 2 / 3; // Відповідь: 3. перша дія зведення в ступінь 3 ** 2=9, потім ділення на 3
1 < 2 > 3 // Відповідь: false, оскільки умова не віконується. 2 не > 3.

(+null == false) < 1; //????

false && true || true // Приоритет &&, поверає false. false || true повертає true. Відповідь: true
false && (true || true); // Приоритет у скобках (true || true). Повертає true. Потім порівнюємо false && true. Повертає false. Відповідь False

(+null == false) < 1 ** 5; //??????